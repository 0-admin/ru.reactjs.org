---
id: glossary
title: Словарь терминов React
layout: docs
category: Reference
permalink: docs/glossary.html

---

## Одностраничное приложение {#single-page-application}

Одностраничное приложение — это приложение, которое состоит из единственной HTML-страницы и прочих ресурсов (таких как JavaScript и CSS), необходимых для успешной работы. Любое взаимодействие с главной или последующими ей страницами не требует контакта с сервером, что значит — страница не требует перезагрузки.


Хоть React и позволяет создавать одностраничные приложения, это совсем не обязательно. React можно использовать для совершенствования небольших частей уже существующих сайтов, чтобы придать дополнительную интерактивность. Код, написанный в React, может мирно сосуществовать с разметкой отрендеренной на сервере с помощью PHP, или с любыми другими фронтенд-библиотеками. По сути, именно так React используется для Facebook.

## ES6, ES2015, ES2016 и т.д. {#es6-es2015-es2016-etc}

Все эти акронимы относяться к самым последним версиям спецификации стандарта ECMAScript, реализацией которого является язык программирования JavaScript. Версия ES6 (также известная как ES2015) включает много дополнений к предыдущим версиям: стрелочные функции, классы, шаблонные строки, ключевые слова `let` и `const`. Более подробно о конкретных версиях вы можно узнать [тут](https://ru.wikipedia.org/wiki/ECMAScript).

## Компиляторы {#compilers}

Компиляторы JavaScript преобразует и возвращает изменённый код. Самый известный случай использования — преобразование синтаксиса ES6 для поддержки в старых браузерах. В работе с React чаще всего используется [Babel](https://babeljs.io/)

## Бандлеры {#bundlers}

Бандлеры совмещают отдельные модули JavaScript и CSS для лучшей оптимизации в браузерах. В работе с React чаще всего используются [Webpack](https://webpack.js.org/) и [Browserify](http://browserify.org/).

## Менеджер пакетов {#package-managers}

Менеджер пакетов — это инструмент позволяющий управлять зависимостями в вашем проекте. [npm](https://www.npmjs.com/) и [Yarn](https://yarnpkg.com/) — менеджеры пакетов наиболее используемые в приложениях React. Оба являются клиентами реестра пакетов npm.

## CDN {#cdn}
Сеть доставки содержимого (англ. Content Delivery Network, CDN) — это сетевая инфраструктура, распространяющая кешированный, статический контент через сеть серверов по всему миру.

## JSX {#jsx}

JSX — расширение синтаксиса JavaScript, которое выглядит как шаблон, но имеет полную силу языка. В результате компиляции JSX и вызова `React.createElement()` возникают простые объекты — «элементы React». Чтобы ознакомиться с введением в JSX, [обратитесь к соответствующему разделу документации](/docs/introducing-jsx.html), а более подробную информацию про JSX вы можете найти [здесь](/docs/jsx-in-depth.html).

React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. Например, в JSX атрибут `tabindex` станет `tabIndex`. В то время как атрибут `class` записывается как `className`, поскольку слово `class` уже зарезервировано в JavaScript:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [Элементы](/docs/rendering-elements.html) {#elements}
Элементы React — это составляющие блоки React-приложений. Их можно перепутать с более известной концепцией «компонентов», но в отличие от компонента, элемент описывает то, что вы хотите увидеть на экране. Элементы React иммутабельны.

```js
const element = <h1>Hello, world</h1>;
```

Обычно, элементы не используются напрямую, а возвращаются компонентами.

## [Компоненты](/docs/components-and-props.html) {#components}

React компоненты — это маленькие, повторно используемые части кода, которые возвращают React-элементы для отображения на странице.
Самый простой компонент React — это простая функция JavaScript, которая возвращает элементы React:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

Компоненты могуть быть классами ES6:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

Компоненты можно разбить на отдельные части в зависимости от выполняемой функции и использовать внутри других компонентов. Компоненты могут возвращать другие компоненты, массивы, строки и числа. Если какая-то часть интерфейса повторяется многократно (`Button`, `Panel`, `Avatar`) или сама по себе достаточно сложная (`App`, `FeedStory`, `Comment`), имеет смысл вынести её в независимый компонент. Имена компонентов всегда должны начинатся с заглавной буквы (`<Wrapper/>`, а **не** `<wrapper/>`). За более детальной информацией по рендерингу компонентов [обратитесь к соответствующему разделу документации](/docs/components-and-props.html#rendering-a-component).

### [`props`](/docs/components-and-props.html) {#props}

`props` (пропсы) — это входные данные компонентов React, передаваемые от компонента-родителя дочернему компоненту.

Помните, `props` предназначены только для чтения. Ни в каком случае их не следует изменять:

```js
// Неправильно!
props.number = 42;
```
Если вам нужно поменять значение в ответ на пользовательский ввод или ответ сервера, используйте `state` (состояние).

### `props.children` {#propschildren}

`props.children` доступны каждому компоненту. Это контент между открывающим и закрывающим тегом компонента. Например:

```js
<Welcome>Hello world!</Welcome>
```

Строка `Hello world!` доступна в `props.children` в компоненте `Welcome`:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

Для классовых компонентов используйте `this.props.children`:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

Компонент нуждается в `state` (состоянии), когда данные в нем со временем изменяются. Например, компоненту `Checkbox` может понадобится состояние `isChecked`, а компоненту `NewsFeed` необходимо отслеживать посты при помощи состояния `fetchedPosts`.

Самая большая разница между `state` и `props` состоит в том, что `props` передаются от родителя потомку, а `state` управляется самим компонентом. Компонент не может воздействовать на `props`, но может изменять `state`.  Для этого он должен вызвать `this.setState()`. Только классовые компоненты могут иметь состояние.


Для каждой отдельной части изменяемых данных должен существовать только один компонент, который «регулирует» изменение состояния. Не пытайтесь синхронизировать сосотояния двух разных компонентов. Вместо этого [поднимите](/docs/lifting-state-up.html) их до ближайшего компонента-родителя и передайте через пропсы необходимым дочерним компонентам. 

## [Методы жизненного цикла](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

Методы жизненного цикла — это настраиваемые функции, которые выполняются на различных этапах жизни компонента. Существуют специальные методы для первоначального рендеринга компонента в DOM ([монтирование](/docs/react-component.html#mounting)), его обновления, размонтирования и удаления.


 ## [Контролируемые](/docs/forms.html#controlled-components) и [неконтролируемые компоненты](/docs/uncontrolled-components.html)

В React существует два различных подхода для управления формами.

Значением элемента формы input под контролем React — это *управляемый компонент*. Когда пользователь вводит данные в управляемый компонент, обработчик события изменений приходит в действие, и ваш код определяет допустим ли ввод (повторно рендерясь с обновленныем значением). Если повторный рендеринг не происходит, елемент формы остаётся без изменений.

*Неконтролируемый компонент* работает как обычный элемент формы вне React. Когда пользователь вводит данные в поле формы (поле ввода, выпадающий список и т.д.), обновлённая информация отображается без помощи React. Однако, это также значит, что некоторые значения не могут быть применены.

В большинстве случаев вам стоит использовать управляемые компоненты.


## [Ключи](/docs/lists-and-keys.html) {#keys}

«Ключ» – это специальный строковый атрибут, который нужно указывать при создании списка элементов. Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными во всём приложении или даже в общем компоненте.


Не передавайте что-либо по типу `Math.random()` через ключи. Необходимо создавать для ключей «постоянные идентификаторы» при повторных рендерингах, чтобы React мог определить когда элементы добавлены, удалены или пересортированы. В идеале, ключи должны соответствовать уникальному и постоянному идентификатору поступающему из ваших данных, такому как `post.id`.

## [Рефы](/docs/refs-and-the-dom.html) {#refs}

React поддерживает особый атрибут, который можно добавить к любому компоненту. Атрибут `ref` может быть объектом, созданным при помощи [функции `React.createRef()`](/docs/react-api.html#reactcreateref) или колбэком, либо же строкой (устаревшее API). Когда атрибут `ref` выступает в роли колбэка, функция получает основной DOM-элемент или экземпляр класса (в зависимости от типа элемента) в качестве аргумента. Это позволяет вам иметь прямой доступ к элементу DOM или экземпляру компонента.

Используйте рефы в исключительных случаях. Если вы часто обращаетесь к рефам за помощью, ознакомьтесь со [снисходящим потоком данных](/docs/lifting-state-up.html).



## [События](/docs/handling-events.html) {#events}

Обработка событий в React-элементах имеет некоторые синтактические особенности:

* Обработчики событий в React именуются в стиле camelCase вместо нижнего регистра.
* С JSX вы передаёте функцию как обработчик события вместо строки.

## [Согласование](/docs/reconciliation.html) {#reconciliation}

Когда пропсы или состояние компонента изменяются, React сравнивает нововозвращенный и предыдущий отрендеренные элементы, и решает нужно ли обновлять DOM. Этот процесс называется «согласование» (reconciliation).
