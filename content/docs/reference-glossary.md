---
id: glossary
title: Словарь терминов React
layout: docs
category: Reference
permalink: docs/glossary.html

---

## Одностраничное приложение {#single-page-application}

Одностраничное приложение — это приложение, которое состоит из единственной HTML страницы и прочих средств (таких как JavaScript и CSS), необходимых для успешной работы. Любое взаимодействие с главной или последующими ей страницами не требует контакта с сервером, что значит — страница не требует перезагрузки.


Хоть React и позволяет создавать одностраничные приложения, это совсем не обязательно. React можно использовать для совершенствования небольших частей уже существующих сайтов, чтобы придать дополнительную интерактивность. Код, написанный в React, может мирно сосуществовать с разметкой отрендеренной на сервере с помощью PHP, или с любыми другими фронтендовыми библиотеками. По сути, именно так React используется для Facebook.

## ES6, ES2015, ES2016, и т.д. {#es6-es2015-es2016-etc}

Все эти акронимы относяться к самым последним версиям спецификации стандарта ECMAScript — языка программирования лежащего в основе JavaScript. Версия ES6 (также известная как ES2015) включает много дополнений к предыдущим версиям: стрелочную функцию, классы, шаблонные строки, переменные `let` и `const`. Более подробно о конкретных версиях вы можно узнать [тут](https://ru.wikipedia.org/wiki/ECMAScript).

## Компиляторы {#compilers}

Компайлер JavaScript преобразует и возвращает изменённый код. Самый известный случай использования — преобразование синтаксиса ES6 для поддержки в старых браузерах. В работе с React чаще всего используется [Babel](https://babeljs.io/)

## Бандлеры {#bundlers}

Бандлеры совмещают отдельные модули JavaScript и CSS для лучшей оптимизации в браузерах. В работе с React чаще всего используются [Webpack](https://webpack.js.org/) и [Browserify](http://browserify.org/).

## Менеджер пакетов {#package-managers}

Менеджер пакетов — это инструмент позволяющий управлять зависимостями в вашем проекте. [npm](https://www.npmjs.com/) и [Yarn](http://yarnpkg.com/) — менеджеры пакетов наиболее используемые в приложениях React. Оба являются клиентам реестра пакетов npm.



## CDN {#cdn}
Сеть доставки содержимого (англ. Content Delivery Network, CDN) — это сетевая инфраструктура, распространяющая кэшированный, статически контент через сеть серверов по всему миру.

## JSX {#jsx}

JSX — расширение синтаксиса JavaScript, которое выглядит как шаблон, но имеет полную силу языка. В результате компиляции JSX и вызова `React.createElement()` возникают простые объекты — "элементы React". Чтобы ознакомиться с введением в JSX, [обратитесь к этой документации](/docs/introducing-jsx.html), более подробную информацию вы можете найти [здесь](/docs/jsx-in-depth.html).

React DOM использует camelCase стиль именования свойств вместо обычных имён HTML атрибутов. Например, в JSX `tabindex` становится `tabIndex`, а атрибут `class` становится `className` поскольку слово `class` уже зарезервировано в JavaScript:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [Элементы](/docs/rendering-elements.html) {#elements}
Элементы React — это составляющие блоки React-приложений. Их можно перепутать с более известной концепцией «компонентов», но в отличии от компонента, элемент описывает то, что вы хотите увидеть на экране. Элементы React иммутабельны.

```js
const element = <h1>Hello, world</h1>;
```

Обычно, элементы не используются напрямую, а возвращаются компонентами.

## [Компоненты](/docs/components-and-props.html) {#components}

React компоненты — это маленькие, повторно используемые части кода, которые возвращают React елементы для отображения на странице.
Самый простой компонент React — это простая JavaScript функция, которая возвращает елементы React:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

Компоненты могуть быть классами ES6:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

Компоненты можно разбить на отдельные части в зависимости от выполняемой функции и использовать внутри других компонентов. Компоненты могут возвращать другие компоненты, массивы, строки и числа. Если какая-то часть интерфейса повторяется многократно (`Button`, `Panel`, `Avatar`) или сама по себе достаточно сложная (`App`, `FeedStory`, `Comment`), имеет смысл вынести её в независимый компонент. Имена компонентов всегда должны начинатся с заглавной буквы (`<Wrapper/>` **не** `<wrapper/>`). За более детальной информацией по рендерингу компонентов [обратитесь к этой документации](/docs/components-and-props.html#rendering-a-component).

### [`пропсы`](/docs/components-and-props.html) {#props}

`пропсы` — это входные данные компонентов React, передаваемые от компонента-родителя дочернему компоненту.

Помните, `пропсы` предназначены только для чтения. Ни в каком случае их не следует менять:

```js
// Неправильно!
props.number = 42;
```
Если вам нужно поменять значение в ответ на пользовательский ввод или ответ сервера, используйте `состояние`.

### `props.children` {#propschildren}

`props.children` доступны каждому компоненту. Это контент между открывающим и закрывающим тегом компонента. Например:

```js
<Welcome>Hello world!</Welcome>
```

Строка `Hello world!` доступна в `props.children` в компоненте `Welcome`:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

Для компонентов-классов используйте `this.props.children`:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`состояние`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

Компонент нуждается в `состоянии`, когда данные в нем со временем изменяются. Например, компоненту `Checkbox` может понадобится состояние `isChecked`, а компоненту `NewsFeed` необходимо отслеживать посты при помощи состояния `fetchedPosts`.

Самая большая разница между `состоянием` и `пропсами` состоит в том, что `пропсы` передаются от родителя потомку, а `состояние` управляется самим компонентом. Компонент не может воздействовать на `пропсы`, но может изменять `состояние`.  Для этого он должен вызвать `this.setState()`. Только классовые компоненты могут иметь состояние.


Для каждой отдельной части изменяемых данных должен существовать только один компонент, который "регулирует" изменение состояния. Не пытайтесь синхронизировать сосотояния двух разных компонентов. Вместо этого, [поднимите](/docs/lifting-state-up.html) их до ближайшего компонента-родителя и передайте через пропсы необходимым дочерним компонентам. 

## [Методы жизненного цикла](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

Методы жизненного цикла — это настраиваемые функции, которые выполняются на различных этапах жизни компонента. Существуют специальные методы для первоначального рендеринга компонента в DOM ([монтирование](/docs/react-component.html#mounting)), его обновления, размонтирования и удаления.


 ## [Управляемые](/docs/forms.html#controlled-components) и [неуправляемые компоненты](/docs/uncontrolled-components.html)

В React существует два различных подхода для управления формами.

Значением элемента формы input под контролем React — это *управляемый компонент*. Когда пользователь вводит данные в управляемый компонент, обработчик события изменений приходит в действие, и ваш код определяет допустим ли ввод (повторно рендерясь с обновленныем значением). Если повторный рендеринг не происходит, елемент формы остаётся без изменений.

*Неуправляемый компонент* работает как обычный  елемент формы вне React. Когда пользователь вводит данные в поле формы (поле ввода, выпадающий список и т.д.), обновлённая информация отображается без помощи React. Однако, это также значит, что некоторые значения не могут быть применены.

В большинстве случаев вам стоит использовать управляемые компоненты.


## [Ключи](/docs/lists-and-keys.html) {#keys}

«Ключ» – это специальный строковый атрибут, который нужно указывать при создании списка элементов. Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными во всем приложении или даже в общем компоненте.


Не передавайте что-либо по типу `Math.random()` через ключи. Важно чтобы ключи имели "стабильное ID" при повторном рендеринге, чтобы React мог определить когда элементы добавлены, удалены или реорганизованы. В идеале, ключи должны соответствовать уникальному и стабильному идентификатору поступающему из ваших данных, такому как post.id`.

## [Рефы](/docs/refs-and-the-dom.html) {#refs}

React поддерживает особый атрибут, который можно добавить к любому компоненту. Атрибут `реф` может быть объектом, созданным при помощи [`React.createRef()` function](/docs/react-api.html#reactcreateref) или функцией-колбэком, или строкой (устаревшее API). Когда атрибут `реф` выступает в роли функции-колбэка, функция получает основной DOM элемент или экземпляр класса (в зависимости от типа элемента) в качестве аргумента. Это позволяет вам иметь прямой доступ к элементу DOM или экземпляру компонента.

Используйте рефы в исключительных случаях. Если вы часто обращаетесь к рефам за помощью, ознакомьтесь со [снисходящим потоком данных](/docs/lifting-state-up.html).



## [События](/docs/handling-events.html) {#events}

Обработка событий в React-элементах имеет некоторые синтактические особенности:

* Обработчики событий в React именуются в стиле camelCase вместо нижнего регистра.
* С JSX вы передаёте функцию как обработчик события вместо строки.

## [Согласование](/docs/reconciliation.html) {#reconciliation}

Когда пропсы или состояние компонента изменяются, React сравнивает нововозвращенный и предыдуще отрендеренный элементы, и решает нужно ли обновлять DOM. Этот процесс называется "согласование".
