---
id: forwarding-refs
title: Перенаправление рефов
permalink: docs/forwarding-refs.html
---

Перенаправление рефов позволяет автоматически передавать [реф](/docs/refs-and-the-dom.html) компонента одному из его дочерних элементов. Как правило, большинство компонентов в приложении не используют эту возможность, но в отдельных случаях, особенно при создании библиотек, она может оказаться полезной. Рассмотрим в каких ситуациях она чаще всего применяется.

## Перенаправление рефов в DOM-компоненты {#forwarding-refs-to-dom-components}

Допустим, у нас есть компонент `FancyButton`, который рендерит нативный DOM-элемент `button`:
`embed:forwarding-refs/fancy-button-simple.js`

В React детали реализации, включая отображение на экране, скрыты внутри компонентов. Реф элемента `button` из `FancyButton` **обычно и не требуется** другим компонентам. Это хорошо, поскольку такой подход не даёт компонентам излишне полагаться на структуру DOM друг друга.

Несмотря на то, что такая инкапсуляция хорошо подходит компонентам, которые описывают некую законченную часть приложения, например `FeedStory` или `Comment`, она может быть неудобной в «маленьких», часто переиспользуемых компонентах, таких как `FancyButton` или `MyTextInput`. Роль таких компонентов в приложении, как правило, аналогична роли обычных DOM-элементов `button` или `input`, и без доступа к их DOM-узлам не получится управлять фокусом, выделением и анимациями. 

**Перенаправление рефов позволяет взять `ref` из атрибутов компонента, и передать его (иначе говоря, «перенаправить») одному из дочерних компонентов.**

В данном примере мы используем `React.forwardRef` в компоненте `FancyButton`, чтобы получить реф и передать его в дочерний DOM-элемент `button`.

`embed:forwarding-refs/fancy-button-simple-ref.js`

Таким образом, когда мы будем применять `FancyButton` в других компонентах, мы сможем получить реф находящегося в нём DOM-узла `button` и использовать его так же, как если бы мы рендерили непосредственно `button`. 

Рассмотрим пошагово, что же просходит в этом примере:

1. Мы создаём [реф](/docs/refs-and-the-dom.html), вызвав `React.createRef` и записываем его в переменную `ref`.
1. Мы передаём переменную `ref` в `<FancyButton ref={ref}>`, указывая её в JSX-атрибуте.
1. React передаёт `ref` в функцию `(props, ref) => ...` внутри `forwardRef` в качестве второго аргумента.
1. Мы передаём аргумент `ref` дальше в `<button ref={ref}>`, указывая его в JSX-атрибуте.
1. После привязки рефа `ref.current` будет указывать на DOM-узел `<button>`.

>Примечание
>
>Второй аргумент `ref` существует только в том случае, если вы создаёте компонент через функцию `React.forwardRef`. Функциональные или классовые компоненты, созданные без использования этой функции, не будут получать `ref` в качестве аргумента или пропа. 
>
>Перенаправить реф можно не только в DOM-компонент, но и в экземпляр классового компонента.

## Примечание для разработчиков библиотек компонентов {#note-for-component-library-maintainers}

**Если вы впервые использовали `forwardRef` в компоненте библиотеки, то это изменение нужно считать критическим, а новую версию следует сделать мажорной.** Причина этого в том, что, скорее всего, поведение этого компонента заметно изменится (например, изменится тип экспортируемых данных и элемент, к которому привязан реф), в результате чего приложения и другие библиотеки, полагающиеся на старое поведение, перестанут работать.

По этой же причине мы не рекомендуем вызывать `React.forwardRef` только при условии, что эта функция определена: поведение библиотеки будет сильно меняться, и приложения ваших пользователей могут перестать работать при обновлении самого React.

## Перенаправление рефов в компонентах высшего порядка {#forwarding-refs-in-higher-order-components}

Особенно полезным перенаправление может оказаться в [компонентах высшего порядка](/docs/higher-order-components.html) (или HOC). Начнём с примера, в котором HOC выводит пропсы компонента в консоль:
`embed:forwarding-refs/log-props-before.js`

Компонент высшего порядка `logProps` передаёт все пропсы в компонент, который он оборачивает, так что рендерить они будут одно и то же. С его помощью мы будем выводить в консоль все пропсы, переданные в наш компонент с кнопкой: 
`embed:forwarding-refs/fancy-button.js`

Обратите внимание, что в этом примере не будут передаваться рефы. Так происходит потому, что `ref` — это не проп. React особенным образом обрабатывает `ref` и `key`. Если вы укажите реф для HOC, он привяжется к ближайшему к корню контейнера, а не к переданному в HOC компоненту.

Следовательно, рефы, предназначенные для компонента `FancyButton`, окажутся привязанными к компоненту `LogProps`:
`embed:forwarding-refs/fancy-button-ref.js`

К счастью, мы можем явно перенаправить рефы на компонент `FancyButton` внутри HOC при помощи API `React.forwardRef`. В `React.forwardRef` передаётся функция рендеринга, которая принимает аргументы `props` и `ref` и возвращает узел React. Например:
`embed:forwarding-refs/log-props-after.js`

## Изменение названия в инструментах разработки {#displaying-a-custom-name-in-devtools}

В `React.forwardRef` передаётся функция рендеринга. Эта функция определяет, как будет называться компонент в инструментах разработки.

Например, вот этот компонент будет называться «*ForwardRef*»:

`embed:forwarding-refs/wrapped-component.js`

Если присвоить имя функции рендеринга, то оно появится в названии компонента в инструментах разработки (например, «*ForwardRef(myFunction)*»):

`embed:forwarding-refs/wrapped-component-with-function-name.js`

Можно даже назначить функции свойство `displayName` и указать в нём какой именно компонент обёрнут в HOC:

`embed:forwarding-refs/customized-display-name.js`
