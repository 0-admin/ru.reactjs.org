---
id: hooks-intro
title: Введение в хуки
permalink: docs/hooks-intro.html
next: hooks-overview.html
---

*Хуки* — новая возможность в React 16.8, которая позволяют использовать состояние и другие возможности React без написания классов.

```js{4,5}
import React, { useState } from 'react';

function Example() {
  // Объявление переменной состояния, которую мы назовём "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

Функция `useState` это первый «хук», который мы изучим, и это всего лишь небольшой пример. Не переживайте, если вы пока не понимаете зачем они нужны.

**Вы можете начать изучать хуки [на следующей странице](/docs/hooks-overview.html).** Здесь же мы расскажем, зачем мы добавили хуки в React, и как они помогут вам писать приложения лучше.

>Примечание
>
>React 16.8.0 это первый релиз, поддерживающий хуки. При обновлении версии, не забудьте обновить все зависимости, включая React DOM. React Native будет поддерживать хуки в следующем стабильном релизе.

## Видео-представление {#video-introduction}

На конференции React Conf 2018, Софи Алперт (Sophie Alpert) и Дэн Абрамов (Dan Abramov) представили хуки, а затем Райн Флоренс (Ryan Florence) показал, как их использовать в приложении. Видео конференции можно посмотреть здесь:

<br>

<iframe width="650" height="366" src="//www.youtube.com/embed/dpw9EHDh2bM" frameborder="0" allowfullscreen></iframe>

## Полная обратная совместимость {#no-breaking-changes}

Перед тем, как мы продолжим, обратите внимание, что хуки:

* **Полностью на ваше усмотрение.** Вы можете попробовать хуки в нескольких компонентах, не изменяя код в уже существующих. Нет необходимости учить и использовать хуки прямо сейчас, если не хотите.
* **100% обратно совместимы.** Хуки не содержат изменений, которые могут поломать ваш существующий код.
* **Доступны прямо сейчас.** Хуки доступны с выходом версии v16.8.0.

**Мы не планируем удалять классы из React.** Вы можете прочитать больше о стратегии постепенного внедрения хуков в [разделе ниже](#gradual-adoption-strategy).

**Хуки не меняют ваши знания о концепциях в React.** Вместо этого, хуки предоставляют более прямой доступ к API уже знакомых вам понятий: пропсы, состояние, контексты, рефы, и жизненный цикл. Позже мы покажем вам, что хуки предоставляют мощный способ для объединения этих концепций.

**Если вы хотите начать изучать хуки, то [переходите на следующую страницу!](/docs/hooks-overview.html)** Вы можете продолжить чтение этой страницы, чтобы узнать больше о том, почему бы добавили хуки и как мы можем использовать их без переписывания нашего приложения.

## Мотивация {#motivation}

Хуки решают множество, казалось бы, несвязанных между собой, проблем в React, с которыми мы сталкивались в течение пяти лет написания и поддержки десятков тысяч компонентов. Если вы изучаете React, используете его ежедневно или используете другую библиотеку с похожим компонентным подходом, вы можете узнать некоторые из этих проблем.

### Трудно переиспользовать логику состояний между компонентами {#its-hard-to-reuse-stateful-logic-between-components}

В React нет способа «присоединить» повторно используемое поведение к компоненту (например, подключение к хранилищу). Если вы работали с React какое-то время, то вам могут быть знакомы такие паттерны, как [рендер-пропсы](/docs/render-props.html) и [компоненты высшего порядка](/docs/higher-order-components.html), которые пытаются решить эту проблему. Но эти паттерны заставляют вас изменять структуру компонентов, что делает код громоздким и трудным в поддержке. Если вы посмотрите на типичное React-приложение в React DevTools, то увидите «ад обёрток» из компонентов, окружённых провайдерами, консьюмерами, компонентами высшего порядка, рендер-пропсами и другими абстракциями. Хоть мы и можем [отфильтровать их в DevTools](https://github.com/facebook/react-devtools/pull/503), но всё это указывает на более глубокую проблему в React. Нужен более удобный способ повторно использовать логику вокруг состояния.

С помощью хуков вы можете извлечь логику состояния из компонента, чтобы протестировать её независимо и повторно использовать. **Хуки позволяют вам переиспользовать логику состояния без изменения структуры компонента.** Это позволяет обмениваться хуками между компонентами или делиться с сообществом.

Мы обсудим это подробнее в разделе [Создание собственных хуков](/docs/hooks-custom.html).

### Сложные компоненты становятся трудными для понимания {#complex-components-become-hard-to-understand}

Нам часто приходилось поддерживать компоненты, которые изначально были простыми, но превратились в неуправляемый беспорядок, состоящий из логики состояния и побочных эффектов. Каждый метод жизненного цикла часто содержит смесь несвязанной логики. Например, компоненты могут загружать данные в `componentDidMount` и `componentDidUpdate`. Однако тот же метод `componentDidMount` может содержать несвязанную логику, которая добавляет обработчики события с отменой подписки в `componentWillUnmount`. Взаимосвязанный код, который изменяется вместе, разделяется, но совершенно несвязанный код в конечном итоге объединяется в один метод. Из-за этого слишком легко добавить баги и несоответствия в приложение.

В некоторых случаях невозможно разбить компоненты на более мелкие, потому что логика с состоянием раскидана повсюду. Также их сложно тестировать. Это одна из причин, по которой люди предпочитают использовать в React отдельную библиотеку для управления состоянием. Однако, это добавляет множество абстракций, заставляет прыгать между разными файлами и усложняет повторное использование компонентов.

Чтобы решить эту проблему, **хуки позволяют вам разделять один компонент на маленькие функции, в зависимости от того, какие части связаны (например, подписка или загрузка данных)**, вместо разделения компонентов на основе методов жизненного цикла. Вы также можете контролировать локальное состояние с помощью редюсера, чтобы поведение было более предсказуемым.

Мы обсудим это в разделе [использование эффект-хуков](/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns).

### Классы путают как людей, так и машины {#classes-confuse-both-people-and-machines}

В дополнение к тому, что усложняется организация кода и его переиспользование, мы обнаружили, что классы могут быть большим барьером в изучении React. Вам нужно понимать, как работает `this` в JavaScript, поведение которого отличается от большинства языков. Вам приходится помнить про привязку контекста для обработчиков событий. Без использования нестабильных [синтаксических предложений](https://babeljs.io/docs/en/babel-plugin-transform-class-properties/), код становится многословным. Люди могут прекрасно понимать пропсы, состояние и однонаправленный поток данных, но всё равно путаться с классами. Различия между функциональными и классовыми компонентами в React и тем, когда их использовать, приводит к разногласиям даже между опытными React-разработчиками.

React существует уже около пяти лет и мы хотим убедиться, что он останется актуальным в течение следующих пяти лет. Как показывают [Svelte](https://svelte.technology/), [Angular](https://angular.io/), [Glimmer](https://glimmerjs.com/) и другие технологии, использующие [компиляцию компонентов перед исполнением](https://ru.wikipedia.org/wiki/AOT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F) имеют огромный потенциал в будущем. Особенно, если это не ограничивается шаблонами. Недавно мы экспериментировали со [свёртыванием компонентов](https://github.com/facebook/react/issues/7323) с использованием [Prepack](https://prepack.io/) и мы увидели первые многообещающие результаты. Однако мы заметили, что классовые компоненты могут приводить к ненамеренным паттернам, сводящим оптимизацию на нет. Классы всё ещё являются проблемой для современных инструментов. Например, классы плохо минифицируются, а горячая перезагрузка (hot reloading) ненадёжна и ломает их. Мы хотим предоставить API, который повысит вероятность того, что код можно будет оптимизировать.

Для решения этих проблем, **хуки позволяют вам использовать больше возможностей React без написания классов.** Концептуально, React-компоненты всегда были ближе к функциям. Хуки обеспечивают доступ к функционалу, но не обесценивают опыт использования React. Хуки предоставляют императивные лазейки и не требуют от вас изучения сложных функциональных или реактивных подходов.

>Примеры
>
>[Обзор хуков](/docs/hooks-overview.html) — хорошее начало для изучения хуков.

## Стратегия постепенного внедрения {#gradual-adoption-strategy}

>**TLDR: Мы не планируем удалять классы из React.**

Мы знаем, что React-разработчики сфокусированы на поставке продукта и у них нет времени изучать новый API каждого релиза. Хуки это что-то новое и возможно, лучше подождать больше примеров и уроков, прежде чем начинать их изучение.

Мы также понимаем, что планка для добавления новых примитивов в React очень высока. Поэтому для любопытных читателей мы подготовили [подробный RFC](https://github.com/reactjs/rfcs/pull/68), в котором можно найти больше информации о деталях и техниках решения проблем.

**Важно понимать, что хуки работают рядом с существущим кодом, поэтому вы можете внедрять их постепенно.** Мы делимся этим API, чтобы получить раннюю обратную связь от тех, в сообществе, кто заинтересован в формировании будущего React и мы будем разбирать хуки в открытую.

Наконец, нет никакой необходимости переходить на хуки. Мы рекомендуем избегать любых «больших переписываний», особенно для существующих, сложных классовых компонентов. Вам потребуется немного изменить мировоззрение, чтобы начать «мыслить хуками». По нашему опыту, лучше всего сначала попрактиковаться использовать хуки в новых и некритичных компонентах и убедиться, что все в вашей команде чувствуют себя комфортно с ними. После того, как вы попробуете, не стесняйтесь [отправить нам свой отзыв](https://github.com/facebook/react/issues/new), позитивный или негативный.

Мы намерены охватить все возможные варианты использования классов в хуках, но **мы всё ещё будем поддерживать классовые компоненты в ближайшем будущем.** В Facebook десятки тысяч компонентов, написанных в виде классов, и у нас нет абсолютно никаких планов их переписывать. Вместо этого мы начинаем использовать хуки в новом коде параллельно с классами.

## Часто задаваемые вопросы {#frequently-asked-questions}

Мы подготовили для вас [страницу с FAQ](/docs/hooks-faq.html) с ответами на самые частые вопросы о хуках.

## Следующие шаги {#next-steps}

К концу этой страницы вы должны иметь общее представление о том, какие проблемы решают хуки, но многие детали, возможно, остались непонятны. Не беспокойтесь! **Давайте перейдём на [следующую страницу](/docs/hooks-overview.html), где мы изучим хуки на примерах.**
